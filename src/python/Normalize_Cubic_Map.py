
# read quintic map as real coefficients Cxy
# use output from 'Normalize_Quadratic_Map.py'
# convert to complex coefficients (mu, gij cubic, gij quartic, gij quintic)
# assume quadratic coeff have already been analytically removed
# analytically remove cubic coeff, except g21, keeping quintic overflow
# see attached sheets: Normal Form of Quartic Map, Sep. 4, 2024
#                    : Final Quintic Map, Oct 30, 2024, p.10
# see attachment: Propagation of Cubic/Quartic terms, Feb 27, 2025

# conversions from complex gij to real Cxy, and back, are consistent with 'expand_z.py'
# after transposing and multiplying by appropriate column and row scales

# (this is a cleaned-up version of 'transform_cubic.py')
# March 31, 2025

import numpy as np
import sys

hdr = "8  , 2.279  , NaN , NaN , NaN , NaN , NaN , NaN  , 0, 0.5 , -1.0143963722332607 , 0, 0, 0, 2.2766978846031507 , -3.301169671560568 , 1.7396830255249192 , 2.139570440512328 , -4.127045833391755 , 1.7648998565394607 , 1.0425727136068557 , -6.461973393441107 , -5.208496845550533 ,11.41273899100962 , -9.998732231837273 , -1.426461546326241 , 25.447232452927317 , 3.660635444054387 , -0.9758334820356653 , 0, 1.0143963722332607 , 0.5 , 0, 0, 0, -2.276697884603152 , 3.3011696715605683 , -1.7396830255249194 , -2.139570440512329 , 6.404688801842984 , -14.578493347618668 , 14.488683451031157 , 1.334793024731499 , -3.7296978049112877 ,-16.63290520924131 , 37.131376111681256 , -23.518445022266796 , -20.2682043092706 , 17.93648122428275 , 14.941144675788534"

if hdr.split(',')[11].strip() != '0' or hdr.split(',')[12].strip() != '0' or hdr.split(',')[13].strip() != '0':
    print ("hdr: quadratic terms not zero, ABORT!")
    sys.exit()
if len(hdr.split(',')) == 50:     # generic quintic model (8 + 21 + 21)
    hdr_incr = 21
    print ("success ! quintic")
else:
    print ("Bad header length, not quintic !")
    sys.exit()

def prod_z_z (N1, p4, p3, p2, p1, p0, N2, q4, q3, q2, q1, q0):
    # multiply two (uniform) z polynomials to produce a new z polynomial (quintic)
    # first  : Sum_N1 (gik * z^i * zbar^k), degree N1
    # second : Sum_N2 (gik * z^i * zbar^k), degree N2

    ret = np.zeros((6,6), complex)    # final accumulated coeff of w^i*wbar^k
                                      # generated by z^i*zbar^k
    P = np.array([p4, p3, p2, p1, p0])
    Q = np.array([q4, q3, q2, q1, q0])
    for i in range (N1 + 1):
        for j in range (N2 + 1):
            #print (i, ',', j, ',', N1 + N2 - i - j, ',', i + j, ',', P[i], ',', Q[j])
            ret[N1 + N2 - i - j][i + j] += P[i]*Q[j]
    return ret

def prod_z_zbar (N1, p4, p3, p2, p1, p0, N2, q4, q3, q2, q1, q0):
    # multiply two (uniform) z polynomials to produce a new z polynomial (quintic)
    # first  : Sum_N1 (gik     * z^i * zbar^k) , degree N1
    # second : Sum_N2 (gik_bar * z^k * zbar^i) , degree N2

    ret = np.zeros((6,6), complex)    # final accumulated coeff of w^i*wbar^k
                                      # generated by z^i*zbar^k
    P = np.array([p4, p3, p2, p1, p0])
    Q = np.array([q4.conjugate(), q3.conjugate(), q2.conjugate(), q1.conjugate(), q0.conjugate()])
    for i in range (N1 + 1):
        for j in range (N2 + 1):
            #print (i, ',', j, ',', N1 + N2 - i - j, ',', i + j, ',', P[i], ',', Q[j])
            ret[N1 - i + j][N2 - j + i] += P[i]*Q[j]
    return ret

def prod_zbar_zbar (N1, p4, p3, p2, p1, p0, N2, q4, q3, q2, q1, q0):
    # multiply two (uniform) z polynomials to produce a new z polynomial (quintic)
    # first  : Sum_N1 (gik_bar * z^k * zbar^i) , degree N1
    # second : Sum_N2 (gik_bar * z^k * zbar^i) , degree N2

    ret = np.zeros((6,6), complex)    # final accumulated coeff of w^i*wbar^k
                                      # generated by z^i*zbar^k
    P = np.array([p4.conjugate(), p3.conjugate(), p2.conjugate(), p1.conjugate(), p0.conjugate()])
    Q = np.array([q4.conjugate(), q3.conjugate(), q2.conjugate(), q1.conjugate(), q0.conjugate()])
    for i in range (N1 + 1):
        for j in range (N2 + 1):
            #print (i, ',', j, ',', N1 + N2 - i - j, ',', i + j, ',', P[i], ',', Q[j])
            ret[i + j][N1 + N2 - i - j] += P[i]*Q[j]
    return ret

def concat (Ni, Nj):
    # expand function z^Ni*zbar^Nj in terms of w^l*wbar^m
    # calculate Xnew = Xold*Xin^Ni*Xin_bar*Nj
    Xold = np.zeros((6,6), complex)    # old accumulated coeff of w^l*wbar^m
    Xold[0][0] = 1
    Xnew = np.zeros((6,6), complex)    # new accumulated coeff of w^l*wbar^m
    #print ('\n', Ni, Nj, 'X0\n', X0.transpose().conjugate())
    for ni in range (Ni + Nj):
        if ni < Ni:
            Xin = X0                            # expand fxn z
        else:
            Xin = X0.transpose().conjugate()    # expand fxn zbar
        #print (ni, '\n', Xin)
        Xnew = np.zeros((6,6), complex)         # new accumulated coeff of w^l*wbar^m
        for oldi in range (6):
            for oldj in range (6 - oldi):
                for ini in range (6 - oldi - oldj):
                    for inj in range (6 - oldi - oldj - ini):
                        Xnew[oldi + ini][oldj + inj] += Xold[oldi][oldj]*Xin[ini][inj]
        #print (ni, '\n', Xnew)
        Xold = Xnew            
    return Xnew

def print_arr (arr):
    # print coeff of uniform polynomials
    print ('---------------')
    for i in range (len(arr)):
        for j in range (i + 1):
            print (arr[i - j][j], ',', end='')
        print ()
    print ('---------------')
    return

# parse a header given in the format of 'Chua_Simul_3.java'

g10 = complex(float(hdr.split(',')[9]), float(hdr.split(',')[9 + hdr_incr]))
print ("\ng10                , ", g10)

# for conversion matrices, use transpose of 'Minv' from 'expand_z.py'
# note gij coeff use factorial notation, Cxy do not

Cxy = np.array([complex(float(hdr.split(',')[14]), float(hdr.split(',')[14 + hdr_incr])), complex(float(hdr.split(',')[15]), float(hdr.split(',')[15 + hdr_incr])), \
                complex(float(hdr.split(',')[16]), float(hdr.split(',')[16 + hdr_incr])), complex(float(hdr.split(',')[17]), float(hdr.split(',')[17 + hdr_incr]))])
#print ("Cxy cubic,", Cxy) # see Chua_2D_cubic_variable_c1.py and IV p.9 and V p.2
g30 = 6*np.matmul(Cxy, np.array([complex(1, 0), complex(0, -1), complex(-1, 0), complex(0,  1)]))/8
g21 = 2*np.matmul(Cxy, np.array([complex(3, 0), complex(0, -1), complex( 1, 0), complex(0, -3)]))/8
g12 = 2*np.matmul(Cxy, np.array([complex(3, 0), complex(0,  1), complex( 1, 0), complex(0,  3)]))/8
g03 = 6*np.matmul(Cxy, np.array([complex(1, 0), complex(0,  1), complex(-1, 0), complex(0, -1)]))/8
print ("\ng30 g21 g12 g03    , ", g30, ",", g21, ",", g12, ",", g03)

h30 = g30/(g10*g10*g10 - g10)
h21 = 0j        # g21/(g10*g10*g10.conjugate() - g10)
h12 = g12/(g10*g10.conjugate()*g10.conjugate() - g10)
h03 = g03/(g10.conjugate()*g10.conjugate()*g10.conjugate() - g10)
print ("h30 h21 h12 h03    , ", h30, ",", h21, ",", h12, ",", h03)

Cxy = np.array([complex(float(hdr.split(',')[18]), float(hdr.split(',')[18 + hdr_incr])), complex(float(hdr.split(',')[19]), float(hdr.split(',')[19 + hdr_incr])), \
                complex(float(hdr.split(',')[20]), float(hdr.split(',')[20 + hdr_incr])), complex(float(hdr.split(',')[21]), float(hdr.split(',')[21 + hdr_incr])), \
                complex(float(hdr.split(',')[22]), float(hdr.split(',')[22 + hdr_incr]))])
#print ("Cxy quartic,", Cxy) # see Book 'Averaging' p. 57
g40 = 24*np.matmul(Cxy, np.array([complex(1, 0), complex(0,-1), complex(-1, 0), complex(0, 1), complex( 1, 0)]))/16
g31 =  6*np.matmul(Cxy, np.array([complex(4, 0), complex(0,-2), complex( 0, 0), complex(0,-2), complex(-4, 0)]))/16
g22 =  4*np.matmul(Cxy, np.array([complex(6, 0), complex(0, 0), complex( 2, 0), complex(0, 0), complex( 6, 0)]))/16
g13 =  6*np.matmul(Cxy, np.array([complex(4, 0), complex(0, 2), complex( 0, 0), complex(0, 2), complex(-4, 0)]))/16
g04 = 24*np.matmul(Cxy, np.array([complex(1, 0), complex(0, 1), complex(-1, 0), complex(0,-1), complex( 1, 0)]))/16
print ("\ng40 g31 g22 g13 g04, ", g40, ",", g31, ",", g22, ",", g13, ",", g04)

Cxy = np.array([complex(float(hdr.split(',')[23]), float(hdr.split(',')[23 + hdr_incr])), complex(float(hdr.split(',')[24]), float(hdr.split(',')[24 + hdr_incr])), \
                complex(float(hdr.split(',')[25]), float(hdr.split(',')[25 + hdr_incr])), complex(float(hdr.split(',')[26]), float(hdr.split(',')[26 + hdr_incr])), \
                complex(float(hdr.split(',')[27]), float(hdr.split(',')[27 + hdr_incr])), complex(float(hdr.split(',')[28]), float(hdr.split(',')[28 + hdr_incr]))])
print ("Cxy quintic,", Cxy)
g50 = 120*np.matmul(Cxy, np.array([  1, -1j, -1,  1j,  1,  -1j]))/32
g41 =  24*np.matmul(Cxy, np.array([  5, -3j, -1, -1j, -3,   5j]))/32
g32 =  12*np.matmul(Cxy, np.array([ 10, -2j,  2, -2j,  2, -10j]))/32
g23 =  12*np.matmul(Cxy, np.array([ 10,  2j,  2,  2j,  2,  10j]))/32
g14 =  24*np.matmul(Cxy, np.array([  5,  3j, -1,  1j, -3,  -5j]))/32
g05 = 120*np.matmul(Cxy, np.array([  1,  1j, -1, -1j,  1,   1j]))/32
print ("\ng50 g41 g32 g23 g14 g05, ", g50, ",", g41, ",", g32, ",", g23, ",", g14, ",", g05)

# generate inverse of a cubic z transform to quintic degree
# note that the existing quartic terms are unaffected

A50 = h30*h30/12 + h21*h03.conjugate()/12
A41 = h30*h21/4  + h21*h30/6 + h21*h12.conjugate()/4  + h12*h03.conjugate()/6
A32 = h30*h12/4  + h21*h21/2 + h21*h21.conjugate()/4  + h12*h12.conjugate()/2 + h12*h30/6  + h03*h03.conjugate()/12
A23 = h30*h03/12 + h21*h12/2 + h21*h30.conjugate()/12 + h12*h21.conjugate()/2 + h12*h21/4  + h03*h12.conjugate()/4
A14 =              h21*h03/6 + h12*h30.conjugate()/6                          + h12*h12/4  + h03*h21.conjugate()/4
A05 =                                                                           h12*h03/12 + h03*h30.conjugate()/12
print ("\nA50 A41 A32 A23 A14 A05, ", A50, ",", A41, ",", A32, ",", A23, ",", A14, ",", A05)
print ('--------------------------------------------------------------------')

#   generate the product of a quintic z-map and a cubic transform from z to w
#   to produce a quintic function in w
#   see attachment 'Propagation of Cubic/Quartic terms (Feb 28)

X0 = np.zeros((6,6), complex)    # final accumulated coeff of w^i*wbar^k
                                 # generated by z-map and z(w)
#print (g10, ',', g10*h20/2, ',', g10*h11, ',', g10*h02/2)
X0 += g10*prod_z_z (0, 1, 0, 0, 0, 0, 1,     1,     0,     0,     0,      0)
X0 += g10*prod_z_z (0, 1, 0, 0, 0, 0, 3, h30/6, h21/2, h12/2, h03/6,      0)

X0 += 1.0/6.0*g30*prod_z_z (1,       1,     0,       0, 0, 0, 2,     1,     0,     0,     0,  0)
X0 += 1.0/6.0*g30*prod_z_z (2,       3,     0,       0, 0, 0, 3, h30/6, h21/2, h12/2, h03/6,  0)

X0 += 0.5*g21*prod_z_zbar (2,     1,     0,     0,     0,  0, 1,     1,     0,     0,     0,  0)
X0 += 0.5*g21*prod_z_zbar (4, h30/6, h21/2, h12/2, h03/6,  0, 1,     2,     0,     0,     0,  0)
X0 += 0.5*g21*prod_z_zbar (2,     1,     0,    0,      0,  0, 3, h30/6, h21/2, h12/2, h03/6,  0)

X0 += 0.5*g12*prod_z_zbar (1,     1,     0,     0,     0, 0, 2,      1,     0,     0,     0,  0)
X0 += 0.5*g12*prod_z_zbar (1,     2,     0,     0,     0, 0, 4,  h30/6, h21/2, h12/2, h03/6,  0)
X0 += 0.5*g12*prod_z_zbar (3, h30/6, h21/2, h12/2, h03/6, 0, 2,      1,     0,     0,     0,  0)

X0 += 1.0/6.0*g03*prod_zbar_zbar (1,  1,  0,    0,     0, 0, 2,      1,     0,     0,     0,  0)
X0 += 1.0/6.0*g03*prod_zbar_zbar (2,  3,  0,    0,     0, 0, 3,  h30/6, h21/2, h12/2, h03/6,  0)

X0 += 1.0/24.0*g40*prod_z_z        (2,   1,     0,     0, 0, 0, 2,     1,   0,     0,  0,  0)
X0 += 1.0/6.0*g31*prod_z_zbar      (3,   1,     0,     0, 0, 0, 1,     1,   0,     0,  0,  0)
X0 += 1.0/4.0*g22*prod_z_zbar      (2,   1,     0,     0, 0, 0, 2,     1,   0,     0,  0,  0)
X0 += 1.0/6.0*g13*prod_z_zbar      (1,   1,     0,     0, 0, 0, 3,     1,   0,     0,  0,  0)
X0 += 1.0/24.0*g04*prod_zbar_zbar  (2,   1,     0,     0, 0, 0, 2,     1,   0,     0,  0,  0)

X0 += 1.0/120.0*g50*prod_z_z       (3,   1,     0,     0, 0, 0, 2,     1,   0,     0,  0,  0)
X0 += 1.0/24.0*g41*prod_z_zbar     (4,   1,     0,     0, 0, 0, 1,     1,   0,     0,  0,  0)
X0 += 1.0/12.0*g32*prod_z_zbar     (3,   1,     0,     0, 0, 0, 2,     1,   0,     0,  0,  0)
X0 += 1.0/12.0*g23*prod_z_zbar     (2,   1,     0,     0, 0, 0, 3,     1,   0,     0,  0,  0)
X0 += 1.0/24.0*g14*prod_z_zbar     (1,   1,     0,     0, 0, 0, 4,     1,   0,     0,  0,  0)
X0 += 1.0/120.0*g05*prod_zbar_zbar (3,   1,     0,     0, 0, 0, 2,     1,   0,     0,  0,  0)

print ('X0 =\n', X0)
print ('arr X0')
print_arr (X0)

# invert the z(w) transform

W = np.zeros((6,6), complex)    # final w-map, based on X0: coeff of w^l*wbar^m
W = W + concat(1, 0) - h30*concat(3, 0)/6 - h21*concat(2, 1)/2 - h12*concat(1, 2)/2 - h03*concat(0, 3)/6
W = W + A50*concat(5, 0) + A41*concat(4, 1) + A32*concat(3, 2) + A23*concat(2, 3) + A14*concat(1, 4) + A05*concat(0, 5)

print ('W =\n', W)
print ('arr W')
print_arr (W)

# extract complex gij (non-factorial) notation of 'uniform_quartic.py'

Q3 = (W[3][0], W[2][1], W[1][2], W[0][3])
Q4 = (W[4][0], W[3][1], W[2][2], W[1][3], W[0][4])
Q5 = (W[5][0], W[4][1], W[3][2], W[2][3], W[1][4], W[0][5])
#Q3 = (0, W[2][1], 0, 0)        # redundant (keep only cylindrically symmetric)
Q4 = (0, 0, 0, 0, 0)            # DISABLE ALL quartic terms
Q5 = (0, 0, W[3][2], 0, 0, 0)   # keep only cylindrically symmetric

print ("\nQ3, ", Q3)
print ("\nQ4, ", Q4)
print ("\nQ5, ", Q5)

# convert from gij (non-factorial) to complex (transformed) Dxy (non-factorial)
# for conversion matrices, use transpose of 'M' from 'expand_z.py'

D30 = np.matmul(Q3, np.array([  1,   1,   1,   1])) 
D21 = np.matmul(Q3, np.array([ 3j,  1j, -1j, -3j]))
D12 = np.matmul(Q3, np.array([ -3,   1,   1,  -3]))
D03 = np.matmul(Q3, np.array([-1j,  1j, -1j,  1j]))
print ("\nD30 D21 D12 D03    , ", D30, ",", D21, ",", D12, ",", D03)

D40 = np.matmul(Q4, np.array([  1,   1,   1,   1,   1])) 
D31 = np.matmul(Q4, np.array([ 4j,  2j,  0j, -2j, -4j]))
D22 = np.matmul(Q4, np.array([ -6,   0,   2,   0,  -6]))
D13 = np.matmul(Q4, np.array([-4j,  2j,  0j, -2j,  4j]))
D04 = np.matmul(Q4, np.array([  1,  -1,   1,  -1,   1]))
print ("\nD40 D31 D22 D13 D04, ", D40, ",", D31, ",", D22, ",", D13, ",", D04)

D50 = np.matmul(Q5, np.array([   1,   1,   1,   1,   1,   1])) 
D41 = np.matmul(Q5, np.array([  5j,  3j,  1j, -1j, -3j, -5j]))
D32 = np.matmul(Q5, np.array([ -10,  -2,   2,   2,  -2, -10]))
D23 = np.matmul(Q5, np.array([-10j,  2j,  2j, -2j, -2j, 10j]))
D14 = np.matmul(Q5, np.array([   5,  -3,   1,   1,  -3,   5]))
D05 = np.matmul(Q5, np.array([  1j, -1j,  1j, -1j,  1j, -1j]))
print ("\nD50 D41 D32 D23 D14 D05, ", D50, ",", D41, ",", D32, ",", D23, ",", D14, ",", D05)
print ()

#   print header for 'poly_roots.py'

print ('poly_roots = "', hdr.split(',')[0].strip(), ',',hdr.split(',')[1].strip(), ',', hdr.split(',')[2].strip(), ',', hdr.split(',')[3].strip(), ',', g10.real, ',', g10.imag, ',', Q3[1].real, ',', Q3[1].imag, ',', Q5[2].real, ',', Q5[2].imag, '"\n')

#   print transformed Dxy hdr

print ('    private static String hdr = "', end='')
temp = hdr.split(',')
for i in range(8):
    print (temp[i], ",", end='')
print (" 0,", g10.real, ",",-g10.imag, ", 0, 0, 0,", D30.real, ",", D21.real, ",", D12.real, ",", D03.real, ",", D40.real, ",", D31.real, ",", D22.real, ",", D13.real, ",", D04.real, ",", end='')
print (D50.real, ",", D41.real, ",", D32.real, ",", D23.real, ",", D14.real, ",", D05.real, ",", end='')
print (" 0,", g10.imag, ",", g10.real, ", 0, 0, 0,", D30.imag, ",", D21.imag, ",", D12.imag, ",", D03.imag, ",", D40.imag, ",", D31.imag, ",", D22.imag, ",", D13.imag, ",", D04.imag, ",", end='')
print (D50.imag, ",", D41.imag, ",", D32.imag, ",", D23.imag, ",", D14.imag, ",", D05.imag, end='')
print ('";')
